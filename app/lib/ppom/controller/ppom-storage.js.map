{"version":3,"file":"ppom-storage.js","sourceRoot":"","sources":["../src/ppom-storage.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @type FileMetadata\n * Defined type for information about file saved in storage backend.\n * @property name - Name of the file.\n * @property chainId - ChainId for file.\n * @property version - File version.\n * @property checksum - Checksum of file data.\n */\nexport type FileMetadata = {\n  name: string;\n  chainId: string;\n  version: string;\n  checksum: string;\n};\n\n/**\n * @type FileMetadataList\n * This is type of metadata about files saved in storage,\n * this information is saved in PPOMController state.\n */\nexport type FileMetadataList = FileMetadata[];\n\n/**\n * @type StorageKey\n * This defines type of key that is used for indexing file data saved in StorageBackend.\n * @property name - Name of the file.\n * @property chainId - ChainId for file.\n */\nexport type StorageKey = {\n  name: string;\n  chainId: string;\n};\n\n/**\n * @type StorageBackend\n * This defines type for storage backend implementation.\n * There will be different storage implementations depending on platform:\n * 1. extension - indexDB\n * 2. mobile app - <TBD>\n * @property read - Read file from storage.\n * @property write - Write file to storage.\n * @property delete - Delete file from storage.\n * @property dir - Get list of all files in storage.\n */\nexport type StorageBackend = {\n  read(key: StorageKey, checksum: string): Promise<ArrayBuffer>;\n  write(key: StorageKey, data: ArrayBuffer, checksum: string): Promise<void>;\n  delete(key: StorageKey): Promise<void>;\n  dir(): Promise<StorageKey[]>;\n};\n\n/**\n * @class PPOMStorage\n * This class is responsible for managing the local storage\n * It provides the following functionalities:\n * 1. Sync the metadata with the version info from the cdn\n * 2. Read a file from the local storage\n * 3. Write a file to the local storage\n *\n * It also validates the checksum of the file when reading and writing in order to\n * detect corrupted files or files that are not up to date\n */\nexport class PPOMStorage {\n  readonly #storageBackend: StorageBackend;\n\n  readonly #readMetadata: () => FileMetadataList;\n\n  readonly #writeMetadata: (metadata: FileMetadataList) => void;\n\n  /**\n   * Creates a PPOMStorage instance.\n   *\n   * @param options - The options passed to the function.\n   * @param options.storageBackend - The storage backend to use for the local storage.\n   * @param options.readMetadata - A function to read the metadata from the local storage.\n   * @param options.writeMetadata - A function to write the metadata to the local storage.\n   */\n  constructor({\n    storageBackend,\n    readMetadata,\n    writeMetadata,\n  }: {\n    storageBackend: StorageBackend;\n    readMetadata: () => FileMetadataList;\n    writeMetadata: (metadata: FileMetadataList) => void;\n  }) {\n    this.#storageBackend = storageBackend;\n    this.#readMetadata = readMetadata;\n    this.#writeMetadata = writeMetadata;\n  }\n\n  /**\n   * Sync the metadata with the version info from the cdn.\n   * 1. Remove the files that are not readable (e.g. corrupted or deleted).\n   * 2. Remove the files that are not in the cdn anymore.\n   * 3. Remove the files that are not up to date in the cdn.\n   * 4. Remove the files that are not in the local storage from the metadata.\n   * 5. Delete the files that are not in the metadata from the local storage.\n   *\n   * @param versionInfo - Version information of metadata files.\n   */\n  async syncMetadata(versionInfo: FileMetadataList): Promise<FileMetadataList> {\n    const metadata = this.#readMetadata();\n    const syncedMetadata: FileMetadataList = [];\n\n    for (const fileMetadata of metadata) {\n      // check if the file is readable (e.g. corrupted or deleted)\n      try {\n        await this.readFile(fileMetadata.name, fileMetadata.chainId);\n      } catch (exp: any) {\n        console.error('Error: ', exp);\n        continue;\n      }\n\n      // check if the file exits and up to date in the storage\n      if (\n        !versionInfo.find(\n          (file) =>\n            file.name === fileMetadata.name &&\n            file.chainId === fileMetadata.chainId &&\n            file.version === fileMetadata.version &&\n            file.checksum === fileMetadata.checksum,\n        )\n      ) {\n        continue;\n      }\n\n      syncedMetadata.push(fileMetadata);\n    }\n\n    const filesInDB = await this.#storageBackend.dir();\n    for (const { name, chainId } of filesInDB) {\n      if (\n        !syncedMetadata.find(\n          (file) => file.name === name && file.chainId === chainId,\n        )\n      ) {\n        await this.#storageBackend.delete({ name, chainId });\n      }\n    }\n\n    this.#writeMetadata(syncedMetadata);\n    return syncedMetadata;\n  }\n\n  /**\n   * Read the file from the local storage.\n   * 1. Check if the file exists in the local storage.\n   * 2. Check if the file exists in the metadata.\n   *\n   * @param name - Name assigned to storage.\n   * @param chainId - ChainId for which file is queried.\n   */\n  async readFile(name: string, chainId: string): Promise<ArrayBuffer> {\n    const metadata = this.#readMetadata();\n    const fileMetadata = metadata.find(\n      (file) => file.name === name && file.chainId === chainId,\n    );\n    if (!fileMetadata) {\n      throw new Error(`File metadata (${name}, ${chainId}) not found`);\n    }\n\n    const data = await this.#storageBackend.read(\n      { name, chainId },\n      fileMetadata.checksum,\n    );\n    if (!data) {\n      throw new Error(`Storage File (${name}, ${chainId}) not found`);\n    }\n\n    return data;\n  }\n\n  /**\n   * Write the file to the local storage.\n   * 1. Write the file to the local storage.\n   * 2. Update the metadata.\n   *\n   * @param options - Object passed to write to storage.\n   * @param options.data - File data to be written.\n   * @param options.name - Name to be assigned to the storage.\n   * @param options.chainId - Current ChainId.\n   * @param options.version - Version of file.\n   * @param options.checksum - Checksum of file.\n   */\n  async writeFile({\n    data,\n    name,\n    chainId,\n    version,\n    checksum,\n  }: {\n    data: ArrayBuffer;\n    name: string;\n    chainId: string;\n    version: string;\n    checksum: string;\n  }): Promise<void> {\n    await this.#storageBackend.write({ name, chainId }, data, checksum);\n\n    const metadata = this.#readMetadata();\n    const fileMetadata = metadata.find(\n      (file) => file.name === name && file.chainId === chainId,\n    );\n\n    if (fileMetadata) {\n      fileMetadata.version = version;\n      fileMetadata.checksum = checksum;\n    } else {\n      metadata.push({ name, chainId, version, checksum });\n    }\n\n    this.#writeMetadata(metadata);\n  }\n}\n"]}